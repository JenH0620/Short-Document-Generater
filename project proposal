项目企划：
使用Python或C++，写一个能够将A文本转换为B文本的小程序。
其特定的用在将权利要求书转换为通知书。
由于A和B文本均为规范的短文本领域，解决从A文档生成B文档的重复性操作，防止在重复性操作中出现低级错误。

（2021年04月26日）
Input： 文档A
step 1: （分词或者直接正则表达式）获得A中特定引用关系的内容
step 2: 树结构可视化表示
step 3: 预定义提示逻辑，用户输入节点的信息（节点为一个特定数据结构）
step 4: 预定义映射关系：节点信息，引用关系->文本
Output：获得输出文档B

（2021年04月27日）
文档A，权利要求书，假设为txt文件，通常符合以下规律：
1. 一种xxxxxx的xxx,其特征在于，xxxxxxxx
2. 根据权利要求1所述的xxx，xxxxxx
3. 根据权利要求1-2所述的xxx，xxxxxx

文档A包含的信息：
a. 主体名称（与独权、从权密切相关，也即会产生）
b. 每条权利要求引用的权利要求
c. 多少条权利要求
----据此可以建立出多棵树，包括：1、是否独权（是否引用，主题是否相同）；2、树结构定位（例如1-3-4-7，或者12-13）
d. 重复度，高重复度意味着评述更有可能相同
e. 每个节点包含信息：
简易版节点数据结构定义：
<序号，{新创性条款，是否假定评述，{权利要求引用部分（x），对比文件号},...,{权利要求引用部分（x），对比文件号}，是否公知}>
完整版节点数据结构定义：
<序号，{新创性前判断条款，权利要求引用部分}，{新创性条款，是否假定评述，{权利要求引用部分（x），对比文件号},...,{权利要求引用部分（x），对比文件号}，是否公知},{新创性后判断条款，权利要求引用部分}>
f.tf-idf简单挖掘（暂时不做）

=====
总结：文档A的数据结构定义为：
序号，主题，引用的序号，是否独权，树结构位置| {新创性前判断条款，权利要求引用部分}，{新创性条款，是否假定评述，{权利要求引用部分（x），对比文件号},...,{权利要求引用部分（x），对比文件号}，是否公知},{新创性后判断条款，权利要求引用部分}

（2021年04月28日）
参数表示：
序号: n:int
主题: tit(n):str
引用的序号: m(n):array [,]
是否独权: 独权无引用，独权有引用，从权有引用
  独权判断规则：
  权1必为独权
  无引用或引用主题不同；也即，m(n)为空 或 tit(n) != tit(m(n))
树结构位置：所有引用关系可以形成矩阵
如：
0 | 0 0 0 0 0 0
1 | 1 0 0 0 0 0
1 | 0 1 0 0 0 0
1 | 1 0 1 0 0 0
0 | 0 0 0 0 0 0
0 | 1 1 1 1 0 0
第一位代表是否从权（0 为独权，1为从权，右边求和若为0，则左边必为0，此时独权无引用；若求和不为0，则左边为0时为独权有引用；若右边求和不为0，左边为1，则从权有引用），右边的矩阵一定是个严格下三角
{新创性前判断条款，权利要求引用部分}，{新创性条款，是否假定评述，{权利要求引用部分（x），对比文件号},...,{权利要求引用部分（x），对比文件号}，是否公知},{新创性后判断条款，权利要求引用部分}

定义规则：

